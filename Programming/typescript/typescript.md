#typescript
### Ссылки
[Документация на руссском](https://scriptdev.ru/guide/000/)
[Онлайн компилятор](https://www.typescriptlang.org/play/?#code/Q)
[Таблица совместимостей](https://www.typescriptlang.org/docs/handbook/type-compatibility.html#any-unknown-object-void-undefined-null-and-never-assignability)
[Задачи по TS](https://github.com/typescript-exercises/typescript-exercises)
[Теория + Задачи](https://code-basics.com/ru/languages/typescript)

## Команды
### Терминал

| `npm install -g typescript`              | Установка typescript                           |
| ---------------------------------------- | ---------------------------------------------- |
| `npm i ts-node -g`                       | Установка ts-node                              |
| `npx create-react-app my-app --template` | typescript React+TS                            |
| `tsc -help`                              | Список команд                                  |
| `tsc --init`                             | Инициализировать проект                        |
| `tsc index.ts (tsc)	`                    | Запустить компилятор                           |
| `tsc -w index.ts`                        | Автоматическая перекомпиляция (--watch)        |
| `clear`                                  | Очистить консоль                               |
| `node index.js`                          | Выполнить код из файла в терминале             |
| `ts-node index.ts`                       | Выполнить код                                  |
| `(//@ts-ignore)`                         | игнорировать предупреждения в следующей строке |
### tsconfig.json 

| `noImplicitAny`                | Отключить ошибки при типе any                   |
| ------------------------------ | ----------------------------------------------- |
| `strictNullChecks`             | Отключить ошибки при типе undefind              |
| `strictNullChecks`             | Отключить ошибки при значении null и undefined  |
| `"target": "es2016"`           | Версия стандарта JS                             |
| `strictPropertyInitialization` | проверка свойств класса, которые еще не созданы |
| `allowJs`                      | Разрешить писать на JS                          |
| `checkJs`                      | Проверка JS                                     |
| `outDir`                       | Куда класть js файлы                            |
| `removeComments`               | Удалять комменты                                |
| `noEmitOnError`                | Не компилировать при ошибке                     |
| `inlineSourceMap`              | Сохранять пути к ошибкам                        |
| `rootDir`                      | Куда компилировать модули                       |
## Теория
### Основы
Этап, на котором происходит контроль типов, определяет вид типизации.
Контроль типов, который происходит на этапе компиляции,
	называется статическим контролем типов или статической типизацией.
Контроль типов, который происходит на этапе выполнения программы,
	называется динамическим контролем типов или динамической типизацией.

Тип данных (или просто тип) — это характеристика, определяющая множество значений и операций,	которые могут быть выполнены над этими данными.

Типы данных делятся на два вида:
типы значения (value type) - хранят значение (их ещё называют значимыми типами)
сылочные типы (reference types) - хранят ссылку на значение

При операции присваивания значения, принадлежащего к значимому типу, данные копируются (дублируются) в памяти.
При операции присваивания значения, принадлежащего к ссылочным типам, копируется лишь ссылка на данные.

Если переменная объявлена, но ей не присвоено значение в ts это any (а не undefined)

Примитивы – это простые типы данных, строки, числа, булевы значения, символы и тд.
Литералы – это конкретные значения этих типов.
Примитивные литеральные типы - это типы на основании конкретных значений примитивов

### Типы данных

#### undefined & null
>undefined 	Что-то еще не инициализированное
null				Что-то недоступное в данный момент (явно нет в данный момент)
null нужно использовать когда хотим осознанно указать что чего-то нет и не будет

#### void
>Основное предназначение типа Void — явно указывать на то, что у функции или метода отсутствует возвращаемое значение.
Означает что у ф-ции нет возвращаемого значения или есть, но оно будет проигнорировано
Тип данных Void указывается с помощью ключевого слова void и,
в отличие от таких типов, как null и undefined, не имеет никаких значений.

#### never
>Примитивный типа данных Never служит для указания того, что какие-либо операции никогда не будут выполнены.
Never обозначается ключевым словом never и так же, как и void, не имеет явных значений.
Тип never можно указать только той функции, из которой программа действительно никогда не сможет выйти
Такой сценарий может выражаться в виде функции, вызов которой приведет к однозначному исключению 
(часто используется в ф-ях, которые возвращают ошибку) или тело функции будет включать бесконечный цикл.

#### unknown 
>Является типобезопасным аналогом any
Опасность any в том, что это любой тип. В нем нет никакой строгости. Никакие проверки типов в нем не выполняются.
unknow это неизвестный тип. В any может быть что угодно, а в unknown – мы не знаем что может быть.
К чему угодно (any) может применятся что угодно, а к неизвестному (unknown) – ничего
Для работы с этим типом необходимо использовать сужение типов.
Данный тип можно использовать для работы с функциями, которые возвращают что-угодно.
Например, JSON.parse(). Так мы избежим ошибок и правильно будем работать с данными

#### Работа с union и intersection типами: 
>Если тип unknown составляет тип объединение (union), то он перекроет все типы, за исключением типа any	Если тип unknown составляет тип пересечение (intersection), то он будет перекрыт всеми типами

#### optional operator '?' 
>Он позволяет сделать запрос к свойству или методу объекта и если его нет, то просто вернуть undefined.
Это позволяет избегать ошибок
В функциях optional operator устанавливается после названия аргумента

#### Объединение '|' (Union)
>Это мощный механизм, позволяющий создавать из множества существующих типов логическое условие,
по которому данные могут принадлежать только к одному из указанных типов.
Объединение указывается с помощью оператора '|', по обе стороны которой располагаются типы данных.
```ts
	let message: string | number = 5
```
Можно использовать только операции, доступные со всеми типами в union типе. Иначе будет ошибка

#### Пересечение & (Intersection)
>Мощный механизм TypeScript, который позволяет рассматривать множество типов данных как единое целое.
Пересечение указывается с помощью оператора амперсанда &, по обе стороны которого указываются типы данных.
```ts
	let v1: T1 & T2 & T3
```
Переменной, которой был указан тип пересечение A и B и С, должно быть присвоено значение,
	принадлежащее к типам A и B и C одновременно.
Другими словами, значение должно обладать всеми обязательными признаками каждого типа, определяющего пересечение.

В структурной типизации об объектном типе можно думать, как об описании структуры, 
которое накладывает ограничения на присваиваемые значения. 	Или как о множестве объектов, которые могут быть присвоены переменной с таким типом.
Когда при пересечении объектных типов встречаются поля с одинаковыми именами, 
то в результате типы этих полей будут также пересечены, и итоговый тип будет never.

#### Non-Null and Non-Undefined - '!'
>Для указания того, что сущность точно существует
Даже если TS будет предупреждать вас об ошибке, то этот оператор отключит это поведение.
Использовать его стоит только тогда, когда уверены в наличии сущности. Иначе будут ошибки в рантайме
Оператор позволяет подкорректировать логику TS и сказать, что функция точно будет синхронной.
И другие ситуации, когда TS не уверен в существовании чего-либо на момент использования

```ts
	let name: string
// (еще не присвоено значение) Чтобы не подсвечивалась ошибка добавляем '!'
	console.log(name!) 
	function(){
		name = "Alex"
	}
```


#### readonly
>TS позволяет на уровне синтаксиса сказать, что свойства объекта, массивы или кортежи являются неизменяемыми.
Любая операция, направленная на это, будет воспринята как ошибка. 
При использовании readonly на массиве, он и его содержимое становятся неизменяемыми.
Такие методы как pop(), push() и тп работать не будут. В кортежах тоже самое

```ts
	interface User{
		readonly login: string
	}
```

альтернативный синтаксис для объектов:
```ts
// Сделать interface User неизменяемым
	const user: Readonly<User>{ 
		login: 'qwerty',
		password: '***'
	}
```

альтернативный синтаксис для массивов:
```ts
	const basicPort: ReadonlyArray<number> = [3000, 3001, 5555]
```

Так же существуют операторы “+” и “-”, которые добавляют или убирают readonly и ? из исходного типа. 
Оператор “+” аналогичен записи выше, когда идет простое добавление

#### Enum (перечисления)
>enum представляет собой набор логически связанных констант,	в качестве значений которых могут выступать как числа, так и строки.
Идентификаторы-имена для перечислений enum принято задавать во множественном числе.
Часто используется когда есть ограниченное число сущностей 
При компиляции в js становятся ф-ями
В случае, когда идентификаторам констант значение не устанавливается явно,	они ассоциируются с числовым значениями, в порядке возрастания, начиная с нуля.
```ts
	enum Fruits {
		Apple, // 0
		Pear, // 1
		Banana, // 2
	}
```

При обращении к константе перечисления через точечную нотацию, будет возвращено значение.
 ```ts
	let value: number = Fruits.Apple // 0
```
А при обращении к перечислению с помощью скобочной нотации и указания значения в качестве ключа,
будет возвращено строковое представление идентификатора константы.
```ts
let identificator: string = Fruits[value]; // “Apple”
```

Перечисление enum, объявленное с помощью ключевого слова const,
	после компиляции не оставляет в коде привычных конструкций.
Вместо этого компилятор встраивает литералы значений в места,
	в которых происходит обращение к значениям перечисления
Обычный Enum в js это ф-я, константный - константа

#### Array
>Если при объявлении массива указать тип string[], то он сможет хранить только элементы,принадлежащие или совместимые с типом string (например, null, undefined, literal type string)
```ts
var animalAll: string[] = ['Elephant', 'Rhino', 'Gorilla']
let names: Array<string> = ["Tom", "Bob", "Alice"]
```

#### Tuple (кортеж) 
>Описывает строгую последовательность множества типов, каждый из которых ограничивает элемент массива с аналогичным индексом.
Простыми словами, кортеж задает уникальный тип для каждого элемента массива.
Перечисляемые типы обрамляются в квадратные скобки, а их индексация, так же как у массива начинается с нуля - [T1, T2, T3].
Типы элементов массива, выступающего в качестве значения,
должны быть совместимы с типами обусловленных кортежем под аналогичными индексами.
```ts
	let v0: [string, number] = ['Dambo', 1]
```
Определение типа кортежа может включать только одно распространение (spread).
Распространение не может быть указано перед необязательными типами.
```ts
const arr:[number, string, ...boolean[]] = [5, 'str', true, false]
```

#### Псевдонимы Типов (types alias)
>Псевдонимы типов можно создавать как для типов объединений, так и для типов пересечений.
```ts
	type SomeType = number | string | boolean; // union type
	
	type OtheType = number & string & boolean; // intersection type
	
	type User = {
		name: string,
		age: number,
		skills: string[]
	}
	type Role = {
		id: number
	}
```

Объединить 2 типа	`typeUserWithRole = User & Role`
Или тип User или Role	`typeUserWithRole = User | Role`

#### Функции
`type Countable = (coll: number[]) => number`

>Внутри типа, который описывает объект, формат ф-ии меняется на используемый для обычных свойств:
```ts
	type User = {
		firstName: string;
		pointsCount: number;
		count(coll: number[]): number;
	}
```

Но это не касается колбеков, которые могут быть использованы внутри:
```ts
	type User = {
		firstName: string;
		pointsCount: number;
		count(coll: (v: string) => string): number;
	}
```

### Продвинутая работа
#### Callback функции
```ts
	function process(callback: () => number)
	function process(callback: () => { firstName: string; })
	function process(callback: (n: number) => string[])
```

#### Interface
>Это синтаксическая конструкция, предназначенная для описания открытой (public) части объекта без реализации (api).
В TypeScript интерфейсы не могут содержать реализацию
Объект, реализующий интерфейс, обязан реализовывать его в полной мере.
В интерфейсы можно помещать только объекты, в type допустимы литералы
Интерфейсы можно расширять. Type - нет.

```ts
	interface IAnimal {
		name: string;
	}

	interface IFlyable {
		flightHeight: number;
	}
```

Объединить интерфейсы
```ts
	interface IAnimalAndFlyable extends IAnimal, IFlyable {
		test: string			// добавить новые свойства
	}
```

Index Signatures
	Если не известно сколько свойств будет в объекте, но известно,
	в каком виде они все будут, то можно использовать специальный синтаксис:

```ts
// для type тоже работает
	interface Style{
		[key: string]: string
	} 
```

#### Сужение типа (Narrowing)
>typeof - когда хотят установить принадлежность к типам:
	number, string, boolean, object, function, symbol или undefined.
instanceof - когда необходимо установить его принадлежность к типу,
	определяемого классом и находящегося в иерархии наследования.
Array.isArray(arr) - для массивов
key in obj - для проверки наличия ключа в объекте

#### Защитник типа (type guard)
>Правила, которые позволяют выводу типов определить суженый диапазон типов	для значения называются защитниками типа: type guards

```ts
	function isNumber(n: unknown): n is number {
		return typeof n === 'number'
	}
```

Функция inNumber вернет true только если аргумент будет числом.
Оператор is позволяет сказать, что будет возвращено логическое значение,
где проверяется, что n это число.

#### Type Queries (запросы типов)
>Позволяет получить тип, связанный со значением по его идентификатору и в дальнейшим использовать его как обычный тип.
Чаще всего он необходим, когда мы четко понимаем, какой тип нам нужен в этой ситуации и он нигде не будет дальше повторяться
Запрос типа осуществляется оператором typeof, после которого идет идентификатор, ссылающийся на значение.
Запрос типа также может располагаться в местах указания типа.
С помощью данного механизма можно получить тип любой конструкции,
будь то переменная, параметр функции или метода, а также член объекта и класса.

```ts
	const dataFromControl = {
		water: 200,
		el: 350,
	}

	function checkReading(data: typeof dataFromControl): void { 
// Взяли типы из dataFromControl
		const datafromUser = {
			water: 200,
			el: 350,
		}
// Сравниваем данные из аргумента с datafromUser
		if ( 
			data.el === datafromUser.el &&
			data.water === datafromUser.water
		) {...}
	}
```

#### Type Assertion (утверждение типа: оператор 'as')
>Если мы точно знаем, что значение свойства подходит,
то мы можем утвердить это значение оператором : as

```ts
	const fetchData = (url: string, method: 'GET' | 'POST'): void => {
		console.log(method)
	}
	const reqOpions = {
		url: 'https:someurl.com',
		method: 'GET'
	 альтернативный способ #1:
		(method: 'GET' as 'GET') // сразу перевести в литерал
	}
```

альтернативный способ #2:
```ts
		const reqOpions = {
			url: 'https:someurl.com',
			method: 'GET'
		} as const // превратить весь объект в литерал типа

	fetchData(reqOpions.url, reqOpions.method as 'GET')
	или:
	fetchData(reqOpions.url, <'GET">reqOpions.method) // конфликт по скобкам (например React)
```

`reqOpions.method` - строка, а ожидается литерал
TS позволяет вам уточнить строку в её литерал (конкретное значение).
Но при изменении значения свойства в объекте TS вам не укажет на ошибку
Доступно лишь утверждение более специализированных типов:
строка - её литерал, число - его литерал и тп. 
В обратную сторону операция не имеет смысла

Часто утверждение типов можно встретить при работе с DOM-деревом,
когда мы хотим уточнить, с каким элементом мы работаем:

```ts
const box = document.querySelector('#box') as HTMLElement	
const input = document.querySelector('input') as HTMLInputElement
```
```ts
const вход = <HTMLInputElement>document.querySelector('input') as HTMLInputElement
```

Конструкция as сделает переменную константой:
`let a = 'value' as const` Тип изменится со 'string' на литерал

#### создание литералов через конструкторTypeScript 
>существует типы, представляющие конструкторы 
одноименных типов из JavaScript (Number, String, Boolean, Symbol, BigInt)
Также существуют типы, представляющий примитивные значения
литералов (number, string, boolean, symbol, bigInt)

Тип number неявно преобразуется в тип Number, но не наоборот
Не используйте конструкторы для создания значений.
Это может привести к непонятным ошибкам

#### Преобразование типов
>Ф-я принимает объект с типом User и на основании его создает объект с типом Admin
```ts
	function userToAdmin(user: User): Admin {
		return {
			name: user.name,
			role: 1
		}
	}
```

#### overload (перегрузка функций)
>Чтобы наглядно прописать все варианты использования функции и задокументировать их, применяется перегрузка
При использовании этого приема подсказки будут более информативны и специфичнее.
Особенно стоит использовать данный прием, если функция сложная и имеет много необязательных аргументов
Необходимо соблюдать несколько правил:
1. Перегрузка записывается до основного тела функции
2. Аргументы могут называться другими именами, это допустимо
3. Все перегрузки должны быть совместимы с главной функцией

Перегрузка:
```ts
	function calculateArea(side: number): Square
	function calculateArea(a: number, b: number): Rect
```

```ts
	function calculateArea(a: number, b?: number): Square | Rect {...}
```

#### контравариантность
>Когда мы передаем аргументы в функцию, то ожидаемые типы параметров должны быть более широкими, чем фактические. 
Такое поведение проверки типов называется контравариантностью.

```ts
type Formatter = (val: string) => string;
const formatToConcrete: Formatter = (): 'test' => 'test';
const formatToNumber: Formatter = (val: '1') => val; // Error!
```
Тип параметров может быть шире, а тип на выходе — уже. 
	В примере formatToConcrete не принимает никаких параметров. 
		Это дает более широкий тип, нежели требуемый string. А возвращает более узкий литеральный тип. 
	formatToNumber ожидает более узкий тип на входе, поэтому и возникает ошибка.

#### Дженерики
>Дженерики в применении к функциям — это механизм, позволяющий создать такие функции, 	которые имеют одинаковую логику обработки для разных типов данных. 
Иногда такие функции называют обобщенными функциями.
Полиморфизм это свойство функции, позволяющее обрабатывать значения разных типов одним способом (используя один алгоритм)
То есть дженерики — это реализация параметрического полиморфизма в TypeScript.
```ts
	function merge<T>(coll1: T[], coll2: T[]): T[]
	function merge<T>(coll1: Array<T>, coll2: Array<T>): Array<T>
	const merge = <T> (coll1:T[], coll2:T[]): T[]
```

Дженерики могут иметь ограничения. Тип, который передается в дженерик,должен реализовывать какой-то интерфейс. 		Для этого используется ключевое слово extends
```ts
	type MyColl<T extends HasId | number> = {}
```
Это позволяет нам использовать тип MyColl только с типами, которые реализуют интерфейс HasId
Тип с методами:
```ts
	type MySet<T> = {
		items: Array<T>
		add(value: T): number,
		has(value: T): boolean}
```
Дженерики с несколькими параметрами:
```ts
		type Double<T, U> = {
			first: T;
			second: U}
```

#### keyof 
>keyof - это оператор, позволяющий получить все свойства объекта, его ключи.
Результат работы - это union type из свойств.
```ts
		type User = {
			id: number;
			name: string;
			email: string;
		}
		type UserFields = User[keyof User]; // string | number
```

#### Omit
>Тип Omit необходим для того, чтобы исключить указанные свойства из другого типа. 
>Второй аргумент может быть только string | number | symbol
Omit<Type, Keys> — создает объектный тип, из которого исключаются ключи Keys из Type

#### Pick 
>Тип Pick необходим для фильтрации типа по заданным свойствам.	Остаются только указанные. Указывать можно только существующие в целевом типе. 
Если их несколько то в union типе
Pick<Type, Keys> — создает объектный тип с ключами Keys из Type

#### работа с dom в TS
>Определенные html-элементы на странице cодержат специфичные для них свойства и методы в дополнение к общим
Все эти интерфейсы нужны для четкого указания с чем мы работаем и правильного доступа к нужным свойствам/методам

```ts
const p = document.querySelector('.some-class') as HTMLParagraphElement
const a = document.querySelector('a') as HTMLAnchorElement
const a = document.querySelector('a') // Автоматически поймет по тегу
```

Если мы указываем селектор, по которому и так понятно, что за элемент будет получен - TS автоматически подставит нужный тип интерфейса. Утверждение в таком случае не нужно
Такая же ситуация и при создании новых элементов через команду createElement()

