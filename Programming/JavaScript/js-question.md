
## JS Темы
### В работе
- Промисификация
- DOM async / defer
- Асинхронность: Сетевые запросы, Клиент-сервер
- Заголовки запросов
--- 
- Import / Export / require()
- Мемоизация в JS
- Css Фигуры
- Регулярные выражения
- ф-ии генераторы & [Symbol.iterator] yield*
---
- цепочка прототипов, прототипное наследование
- ООП Приватные поля
- ООП паттерны
---
- solid
- Тестирование и отладка Jest дебаггинг
- RESTful API
- Функциональные паттерны
- Jira
- ESLint
- WebPack
- Git
- Material UI
- Тесты
- Bootstrap/TaiwindCSS
- Debugger
- Основы Node.js (Создание сервера, встроенные модули)
---
- WebSocket
- Деплой
- Роутинг
- Рефакторинг
- Безопасность

### Материалы
* [Интернет](https://www.youtube.com/watch?v=xnx2JDSV87Y)
* [Браузер и сеть](https://www.youtube.com/watch?v=g94j-ahVR78)|	[Браузер и сеть YouTube](https://www.youtube.com/watch?v=LQb0ocMVAOE)
* [API](https://habr.com/ru/articles/464261/#api)
* [REST](https://www.youtube.com/watch?v=08-RlaLgWx4) [Rest API Soap GraphQL Websockets RPC](https://www.youtube.com/watch?v=XaTwnKLQi4A)
* [Особенности ES6](https://frontend-stuff.com/blog/es6/) | [javascript-es6](https://artzolin.ru/javascript-theory/javascript-es6-features/)
* [Императивный и Декларативный стили](https://doka.guide/tools/programming-paradigms/)
* [Функции первого класса / высшего порядка](https://habr.com/ru/companies/ruvds/articles/428570/)
* [Чистые функции](https://habr.com/ru/articles/437512/)
* [Операции, выражения и инструкции](https://jsflow.org/docs/operators-expressions-statements/)
* [Управ памятью, цикл. ссылка, сборщик мусора](https://developer.mozilla.org/ru/docs/Web/JavaScript/Memory_management)
* [Куки](https://www.youtube.com/watch?v=s04Vjlcgwco)|	[Куки](https://learn.javascript.ru/cookie)
* [каррирование (currying)](https://thecode.media/currying/)
* [Сложность алгоритмов](https://www.youtube.com/watch?v=HekbUG3R2qQ&list=PLuFYDaTQKsepvN89nHukGhoznZhcBH1kA)
* [Strict mode](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Strict_mode)

---

- [Лексическое окружение](https://jsflow.org/docs/lex-env/)|	[Лексическое окружение YouTube](https://www.youtube.com/watch?v=GkmoRy0Kv14	) [Лексическое окружение YouTube](https://www.youtube.com/watch?v=Rc49Z6CNJj0)
- [Замыкания](https://learn.javascript.ru/closures)|	[Замыкания habr](https://habr.com/ru/articles/338462/)																							
* [Временная мертвая зона](https://russianblogs.com/article/34231534838/)
* [Области видимости let и const](https://jsflow.org/docs/block-scope/) |  [Области видимости learn.javascript](https://learn.javascript.ru/closure)
* [Scope and Context в JS](http://ryanmorr.com/understanding-scope-and-context-in-javascript/)
* [Var области видения, всплытие](https://learn.javascript.ru/var)| [области видения doca.guide](https://doka.guide/js/closures/)
* [Поднятие (Hoisting)](https://habr.com/ru/articles/486820/#18	)[Hoisting Mozila.org](https://developer.mozilla.org/ru/docs/Glossary/Hoisting)
* [Преобразования типов в JavaScript](https://habr.com/ru/articles/709048/)
* [This (mozilla.org)](https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/this)| [This (habr)](https://habr.com/ru/articles/785872/)|	[This (habr)](https://habr.com/ru/companies/ruvds/articles/419371/)
* [Рекурсия](https://doka.guide/js/recursion/)
* [EventLoop doka.guide](https://doka.guide/js/async-in-js/)|  [EventLoop YouTube](https://www.youtube.com/watch?v=zDlg64fsQow)|  [EventLoop latentflip.com](http://latentflip.com/loupe/)

---

* [axios](https://my-js.org/docs/cheatsheet/axios)
- [.valueOf .toPrimitive learnJS](https://learn.javascript.ru/object-conversion)|	[Object to primitive learnJS](https://learn.javascript.ru/object-toprimitive)
* [Proxy](https://learn.javascript.ru/proxy)
* [Symbol](https://learn.javascript.ru/symbol)


## Вопросы
### Вопросы по JS
6	11	14	20	37	45	48	55	56	65	70	79	92	98	104	114 119	129	130	132	143
160	164 165 169	182	174	194	196	207	
[roadmap.sh](https://roadmap.sh/questions/javascript)
[my-js.org](https://my-js.org/docs/other/js-questions)
[frontendinterviewhandbook.com](https://www.frontendinterviewhandbook.com/ru/javascript-questions/)
[habr.com](https://habr.com/ru/articles/486820)

### Вопросы по React:
[roadmap.sh](https://roadmap.sh/questions/react)
[my-js.org](https://my-js.org/docs/other/react-questions)

### Q&A

- Метод push возвращает длину нового массива.
- Ключи объекта конвертируются (преобразуются) в строки
- Оператор delete удаляет только значение массива по указанному индексу, сам индекс остается, его значением становится undefined.
При этом, количество элементов в массиве и его длина сохраняются.
- В нестрогом режиме дублирующиеся параметры в обычных функциях разрешены. В отличие от обычных, в стрелочных функциях дублирующиеся параметры запрещены, независимо от режима выполнения кода.
- Стрелочные функции не имеют прототипа, arguments, this, super и new.target.
- REST (Representational State Transfer) — стиль общения компонентов,
при котором все необходимые данные указываются в параметрах запроса.
- Оператор + не предназначен для сложения массивов. Поэтому массивы преобразуются в строки и объединяются.
- NaN не равен никакому другому значению, включая NaN. NaN является числом. В отличии от операторов равенства (`==` и` ===`), для Set все NaN являются одинаковыми
- Асинхронная функция всегда возвращает промис
- new Number - это встроенная функция-конструктор. 
И хотя она выглядит как число, это не настоящее число: у него имеется ряд дополнительных возможностей. При использовании === должны совпадать не только значения, но и типы данных. new Number() - это не число, а объект.
- Нельзя добавлять свойства к конструктору как к обычному объекту. Если необходимо добавить свойство или метод всем экземплярам, то следует использовать прототипы.
- При создании объекта без помощи ключевого слова new создается глобальный объект.
- Импортируемый модуль доступен только для чтения: мы не можем его изменять.
- Оператор delete возвращает логическое значение: true при успешном удалении, иначе - false
Однако, переменные, объявленные с помощью ключевых слов, не могут быть удалены с помощью delete
- Классы являются синтаксическим сахаром для функций-конструкторов.
- Генераторы не могут использоваться в качестве конструкторов, т.е. с ключевым словом new
- Объявления классов не поднимаются в начало области видимости. 
Поэтому использовать класс можно только после его объявления
- undefined, функции и символы не являются валидными JSON-значениями. 
Такие значения не включаются в объект и конвертируются (преобразуются) в null.
- new.target ссылается на конструктор (указывает на класс), который вызывается с помощью ключевого слова new
- С помощью метода defineProperty мы можем добавлять новые свойства к объекту или изменять существующие. Когда мы добавляем свойство к объекту с помощью defineProperty(), они по умолчанию являются не перечисляемыми (enumerable: false)
- Object.freeze() делает невозможным добавление, удаление или изменение свойств объекта (если только значение свойства не является другим объектом) Заморожен ли объект, можно определить посредством Object.isFrozen()
- Сеттеры не имеют собственных значений, их задача - модифицировать свойства объекта. 
Поэтому вызов сеттера возвращает undefined.
- Объекты не являются итерируемыми (перебираемыми) по умолчанию. 
В итерируемых сущностях имеется протокол итератора. 
Мы можем реализовать такой протокол вручную, добавив в объект символ итератора ([Symbol.iterator]), 
который будет возвращать объект-генератор. 
- Оператор spread (распространения или распаковки, ...) применяется только к итерируемым (перебираемым) сущностям. 
Объекты таковыми не являются.

- Контекст выполнения — это среда, в которой выполняется код. 
Контекст выполнения имеет две фазы — компиляция и собственно выполнение.
Компиляция. В этой фазе функциональные выражения и переменные, объявленные с помощью ключевого слова «var», 	со значением undefined поднимаются в самый верх глобальной (или функциональной) области видимости (как бы перемещаются в начало нашего кода. 
Это объясняет, почему мы можем вызывать функции до их объявления — прим. пер.).
Выполнение. В этой фазе переменным присваиваются значения, а функции (или методы объектов) вызываются или выполняются.

- Область видимости — это место, где (или откуда) мы имеем доступ к переменным или функциям.
JS имеем три типа областей видимости: глобальная, функциональная и блочная (ES6).
Область видимости — это также набор правил, по которым осуществляется поиск переменной.
Поиск осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной. 
Это называется цепочкой областей видимости (Scope Chain).
### Методы объекта 
- Object.assign() используется для копирования значений всех собственных перечисляемых свойств в целевой объект
- Object.create() создаёт новый объект с указанным прототипом и свойствами
- Object.defineProperty() определяет новое или изменяет существующее свойство объекта и возвращает этот объект
- Object.entries() возвращает массив собственных перечисляемых свойств указанного объекта в формате [key, value]
- Object.fromEntries() преобразует список пар ключ-значение в объект
- Object.keys() возвращает массив из собственных перечисляемых свойств переданного объекта
- Object.values() возвращает массив значений перечисляемых свойств объекта
- Object.freeze() замораживает объект
- Object.isFrozen() определяет, был ли объект заморожен
- hasOwnProperty() возвращает логическое значение, указывающее, содержит ли объект указанное свойство
- Object.getOwnPropertyNames() возвращает массив со всеми свойствами, независимо от того, перечисляемые они или нет

### Методы Массива 
- Array.from() Создаёт новый экземпляр Array из итерируемого или массивоподобного объекта
- Array.isArray() Возвращает true если аргумент является массивом и false в противном случае
- Array.of() Создаёт новый экземпляр Array с переменным количеством аргументов, независимо от количества или типа аргументов
- every() Проверяет, удовлетворяют ли все элементы массива условию, заданному в передаваемой функции
- fill() Заполняет все элементы массива от начального до конечного индексов одним значением


### Сравнение типов
Выражение typeof ClassName возвращает function
```js
	Boolean([]) === true
	Number([]) === 0
	Number({}) - NaN
	NaN === NaN -	 false
	Boolean(new Boolean(false)) - true (если мы уберем ключевое слово new, то получим false)
	
	typeof(null) - 'object'
	typeof(NaN) - 'number'
	typeof('') - 'string'
	typeof function () {} === "function"
	typeof class C {} === "function"
	
Все функции-конструкторы, созданные с помощью 'new', будут иметь тип 'object'
	typeof new Date() === "object"
	typeof new Boolean(true) === "object"
	typeof new Number(1) === "object"
	typeof new String("abc") === "object"
	
Но существует исключение для конструктора Function:
	var func = new Function()` `typeof func` Вернёт 'function'
```



### Области видимости 
[Области видимости](https://metanit.com/web/javascript/3.2.php)| [Области видимости ](https://college.arthur-nesterenko.dev/javascript/hoisting)
Существуют два типа областей видимости: глобальная и локальная.
Если переменная объявлена вне всех функций или фигурных скобок ({}), 
	то считается, что она определена в глобальной области видимости.
Переменные, которые используются только в определенной части кода,
	считаются помещенными в локальную область видимости. Такие переменные называются локальными.

В JavaScript выделяют два типа локальных областей видимости:
	1. область видимости функции
	2. область видимости блока

>Область видимости функции
Переменная, объявленная внутри функции, доступна только внутри функции.
Код снаружи функции не имеет к ней доступа.
При этом не зависит от того, что это за переменная - var или let, либо const

>Область видимости блока
Переменная, объявленная внутри фигурных скобок {} через const или let, доступна только внутри фигурных скобок.
Переменная, объявленная с помощью var, может использоваться вне блока.
Блочная область видимости является частным случаем области видимости функции, 	т.к. функции объявляются с фигурными скобками

>С помощью var можно использовать значение до того, как оно будет присвоено, и оно вернет undefined.
Если сделать, то же самое с let - будет ReferenceError.

>Подъем функции в области видимости
Функции, объявленные как «function declaration», всегда поднимаются наверх в текущей области видимости.
Если же функция объявляется как «function expression», то такая функция не поднимается в текущей области видимости.

>Функции не имеют доступа к областям видимости других функций, когда они объявляются раздельно, даже если одна функция используется в другой.
Когда функция объявляется в другой функции, то внутренняя функция имеет доступ к переменным внешней функции.
В тоже время внешняя функция не имеет доступа к переменным внутренней функции.

### Домен/протокол/порт 
URL обозначает Uniform Resource Locator.
URL это лишь адрес, который выдан уникальному ресурсу в интернете.
В теории, каждый корректный URL ведёт на уникальный ресурс.
Такими ресурсами могут быть HTML-страница, CSS-файл, изображение и т.д.

>протокол: http://
Он отображает, какой протокол браузер должен использовать.
Обычно это HTTP-протокол или его безопасная версия - HTTPS.
Интернет требует эти 2 протокола, но браузеры часто могут использовать и другие протоколы,
например mailto: (чтобы открыть почтовый клиент) или ftp: для запуска передачи файлов.

>Доменное имя: www.example.com
Оно означает, какой веб-сервер должен быть запрошен.
В качестве альтернативы может быть использован и IP-адрес,
но это делается редко, поскольку запоминать IP сложнее, и это не популярно в интернете.

>Порт :80
Он отображает технический параметр, используемый для доступа к ресурсам на веб-сервере.
Обычно подразумевается, что веб-сервер использует стандартные порты HTTP-протокола (80 для HTTP и 443 для HTTPS) для доступа к своим ресурсам.
В любом случае, порт - это факультативная составная часть URL.

>Адрес ресурса на веб-сервере. /path/to/myfile.html
В прошлом, адрес отображал местоположение реального файла в реальной директории на веб-сервере.
В наши дни это чаще всего абстракция, позволяющая обрабатывать адреса и отображать тот или иной контент из баз данных.

>Дополнительные параметры ?key1=value1&key2=value2
Дополнительные параметры, которые браузер сообщает веб-серверу.
Эти параметры - список пар ключ/значение, которые разделены символом &.
Веб-сервер может использовать эти параметры для исполнения
дополнительных команд перед тем как отдать ресурс.
Каждый веб-сервер имеет свои собственные правила обработки этих параметров и узнать их можно, только спросив владельца сервера.

>Якорь `#SomewhereInTheDocument`
Якорь на другую часть того же самого ресурса.
Якорь представляет собой вид "закладки" внутри ресурса, которая переадресовывает браузер на "заложенную" часть ресурса.
В HTML-документе, например, браузер может переместиться в точку, где установлен якорь;
в видео- или аудио-документе браузер может перейти к времени, на которое ссылается якорь.